# -*- coding: utf-8 -*-
"""
Created on Sat May 10 13:19:39 2025

@author: mi1g20
"""
import numpy as np

def process_umbmark(cw_runs, ccw_runs):
    def compute_displacements(runs):
        return np.array([
            [end_x - start_x, end_y - start_y]
            for start_x, start_y, end_x, end_y in runs
        ])

    # Calculate displacements
    cw_displacements = compute_displacements(cw_runs)
    ccw_displacements = compute_displacements(ccw_runs)

    # Mean displacement
    cw_mean = np.mean(cw_displacements, axis=0)
    ccw_mean = np.mean(ccw_displacements, axis=0)

    # Bias estimation (from UMBmark paper)
    dx = (cw_mean[0] + ccw_mean[0]) / 2
    dy = (cw_mean[1] + ccw_mean[1]) / 2
    bx = (cw_mean[0] - ccw_mean[0]) / 2
    by = (cw_mean[1] - ccw_mean[1]) / 2
    
    # Magnitude of displacement vectors (Equation 3.3)
    r_cg_cw = np.linalg.norm(cw_mean)
    r_cg_ccw = np.linalg.norm(ccw_mean)

    # Systematic odometry error (max of the two magnitudes)
    E_max_syst = max(r_cg_cw, r_cg_ccw)

    print("CW mean error:   X: {:.3f} m, Y: {:.3f} m".format(*cw_mean))
    print("CCW mean error:  X: {:.3f} m, Y: {:.3f} m".format(*ccw_mean))
    print("Average drift:   X: {:.3f} m, Y: {:.3f} m".format(dx, dy))
    print("Systematic bias: X: {:.3f} m, Y: {:.3f} m".format(bx, by))
    print("r_cg_CW: {:.3f} m, r_cg_CCW: {:.3f} m".format(r_cg_cw, r_cg_ccw))
    print("Maximum systematic odometry error (E_max_syst): {:.3f} m".format(E_max_syst))

    return {
        "cw_mean": cw_mean,
        "ccw_mean": ccw_mean,
        "avg_drift": (dx, dy),
        "bias": (bx, by),
        "r_cg_cw": r_cg_cw,
        "r_cg_ccw": r_cg_ccw,
        "E_max_syst": E_max_syst
    }

#%% Test Results
cw_runs = [
    [0.16361560904367023,0.24499707395248016, 0.2117882382510956, 0.06390939018829567],
    [0.1709635124112805,0.25072820278681374, 0.1882340279398642, 0.13150538261516642],
    [0.19941114032508667,0.272811997803989,.21372893178450392,0.19981376061388811],
    [0.18905303183305522,0.25879963691025054, 0.33850864092010324,0.18397418036895896]
    ]

ccw_runs = [
    [0.22345374620013603, 1.8247167896348029, 0.9734746220070987,1.8904992986629612],
    [0.1502537025023729,1.817390100411475,0.14261820994075425, 1.9084537958742298],
    [0.19245684383120398,1.8928188722030854,1.0370989819099792,1.9060862844099726],
    [0.2358713801404737,1.9850797065002816,1.128680165669611,1.9887097977345503]
    ]

# Call the function
results = process_umbmark(cw_runs, ccw_runs)

#%% Propogating errors
# Given parameters from your robot
wheelbase = 0.174  # meters
wheel_diameter = 0.070  # meters
test_velocity = 0.2  # m/s (from your path_velocity)

# From your test results
bx = results["bias"][0]  # Systematic bias in X
by = results["bias"][1]  # Systematic bias in Y
E_max_syst = results["E_max_syst"]  # meters

# 1. Calculate wheel diameter error (E_d)
path_length = 4.0  # 4m total for square
E_d = E_max_syst / path_length
print(f"Wheel diameter error (E_d): {E_d:.6f} m")

# 2. Calculate wheelbase error (E_b) 
# (Using Eq. 7 from Borenstein & Feng)
E_b = (np.abs(bx) * wheelbase) / (4 * path_length)
print(f"Wheelbase error (E_b): {E_b:.6f} m")

# 3. Convert to velocity uncertainties
k_v = 0.5  # Empirical scaling factor (from literature)
k_w = 1.0  # Empirical scaling factor

sigma_v = k_v * E_d * test_velocity
sigma_w = k_w * E_b * np.deg2rad(30)  # Using 30°/s as typical turn rate

print("\nFinal Motion Model Uncertainties:")
print(f"Linear velocity std (σ_v): {sigma_v:.6f} m/s")
print(f"Angular velocity std (σ_w): {sigma_w:.6f} rad/s")

d_corrected = wheel_diameter * (1-E_d)
b_corrected = wheelbase * (1 - E_b)

print(f"Corrected wheel diameter {d_corrected:.6f} m")
print(f"Corrected wheelbase {b_corrected:.6f} m")